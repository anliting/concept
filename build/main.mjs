let e=new Text;class t{constructor(e){this.p=e}sub(t){return n=>{let s=n.node[0];t.undoEffect(n);let i=this.make(n.root),r=i.node,o=t.getNode(n),c=s.parentNode;c.insertBefore(e,s);let l=new DocumentFragment;l.append(...r),c.insertBefore(l,e),c.removeChild(e);for(let e of new Set(o).difference(new Set(r)))c.removeChild(e);return i}}undoEffect(){}}class n{constructor(e,t,n=[]){this.child=n,this.concept=null,this.effect=[],this.functionConcept=null,this.node=t,this.ref={},this.root=e}}let s,i,r,o,c=class extends t{constructor(e){super({}),this.n=e}getNode(e){let t=e.node[0];return t.nextSibling==this.n?[t,t.nextSibling]:[t]}make(e){return new n(e,[new Text,this.n])}sub(e){return e instanceof c&&this.n==e.n?e=>e:super.sub(e)}},l=class extends t{getNode(e){return[e.node[0]]}sub(e){return e instanceof l?e=>{let t=this.make(e.root);return e.node[0].parentNode.replaceChild(t.node[0],e.node[0]),e.child=t.child,e.node=t.node,e}:super.sub(e)}},h=class extends l{constructor(e,t){super(e),this.t=t}make(e){return new n(e,[new Text(this.t)])}sub(e){return e instanceof h?this.t==e.t?e=>e:e=>(e.node[0].nodeValue=this.t,e):super.sub(e)}},u=(e,t)=>{for(let n of e)t.parentNode.insertBefore(n,t.nextSibling),t=n},p=class extends t{constructor(e={},t){super(e),this.c=t.map((e=>"string"==typeof e?new h({},e):e instanceof Node?new c(e):Symbol.iterator in e?new p({},e):e))}getNode(e){return[e.node[0],...this.c.flatMap(((t,n)=>t.getNode(e.child[n])))]}make(e){let t=this.c.map(((t,n)=>t.make(e)));return new n(e,[new Text,...t.flatMap((e=>e.node))],t)}sub(e){return e instanceof p?t=>{let n=t.node[0],s=[],i={};for(let[n,r]of e.c.entries()){let e=r.getNode(t.child[n]);"_key"in r.p?i[r.p._key]={i:n,node:e}:s.push({i:n,node:e}),e.at(-1)}let r={};{let e=0;for(let[t,n]of this.c.entries())"_key"in n.p?n.p._key in i&&(r[t]=i[n.p._key],delete i[n.p._key]):(e in s&&(r[t]=s[e],delete s[e]),e++)}for(let r of function*(){for(let e in s)yield s[e];for(let e of Reflect.ownKeys(i))yield i[e]}()){e.c[r.i].undoEffect(t.child[r.i]);for(let e of r.node)n.parentNode.removeChild(e)}let o=[],c=n;for(let[n,s]of this.c.entries()){let i;r[n]?(c.nextSibling!=r[n].node[0]&&u(r[n].node,c),i=s.sub(e.c[r[n].i])(t.child[r[n].i])):(i=s.make(t.root),u(i.node,c)),o.push(i),c=i.node.at(-1)}return t.child=o,t.node=[n,...o.flatMap((e=>e.node))],t}:super.sub(e)}undoEffect(e){this.c.map(((t,n)=>t.undoEffect(e.child[n])))}},f=e=>(t,...n)=>new e(t,n),d=()=>s.s,a=(e,t)=>{let n=s;s=e;try{return t()}finally{s=n}},y=class{#e;#t;#n;#s=[];render(e=this.concept){a(this.#t,(()=>{this.#n=e.sub(this.concept)(this.#n),this.concept=e}))}constructor(e){this.#t={a:()=>{this.#e=this.#e||requestAnimationFrame((()=>{this.#e=0,this.render()}))},s:()=>this.render()},this.concept=new h({}),this.#n=this.concept.make(this),this.node.append(...this.#n.node),e&&this.render(e)}flush(){a(this.#t,(()=>{this.#s.map((e=>e()))})),this.#s=[]}node=new DocumentFragment;push(e){this.#s.push(e),this.#e=this.#e||requestAnimationFrame((()=>{this.#e=0,this.flush()}))}unmount(){this.node.append(...this.#n.node)}},m=(e,t)=>e.length==t.length&&e.every(((e,n)=>Object.is(e,t[n]))),b=(e,t)=>{i.push([e,t])},w=(e,t)=>{let n=i;i=e;try{return t()}finally{i=n}},k=(e,t)=>{let n=v([e,t]);return m(n.current[1],t)||(n.current=[e,t]),n.current[0]},v=e=>o in r.ref?r.ref[o++]:r.ref[o++]={current:e},g=e=>{let t=r,n=[e,e=>{t.root.push((()=>{n[0]=e,t.concept.sub(t.concept)(t)}))}];return s.a,v(n).current},$=(e,t)=>{let n=r,s=o;r=e,o=0;try{return t()}finally{r=n,o=s}},x=class extends t{constructor(e,t,n){super(e),this.f=t,this.c=n}getNode(e){return e.functionConcept.getNode(e.child[0])}make(e){let t=new n(e);return t.functionConcept=w(t.effect,(()=>$(t,(()=>this.f(this.p,...this.c))))),t.child=[t.functionConcept.make(e)],t.concept=this,t.effect.map((e=>e[0]=e[0]())),t.node=t.child[0].node,t}sub(e){return e instanceof x&&this.f==e.f?e=>{let t=e.functionConcept,n=e.effect,s=[],i=w(s,(()=>$(e,(()=>this.f(this.p,...this.c))))),r=i.sub(t),o=n.map(((e,t)=>t)).filter((e=>{let t=n[e];return!(t[1]&&m(t[1],s[e][1]))}));return o.map((e=>n[e][0]?.())),e.child[0]=r(e.child[0]),e.functionConcept=i,o.map((e=>{let t=s[e];t[0]=t[0]()})),e.concept=this,e.effect=s,e.node=e.child[0].node,e}:super.sub(e)}undoEffect(e){e.effect.map((e=>e[0]?.())),e.effect=[],e.functionConcept.undoEffect(e.child[0])}},_=e=>(t,...n)=>new x(t,e,n),C=class extends l{constructor(e,t,n){super(t),this.t=e,this.c=n}make(e){let t=document.createElement(this.t);t.appendChild(new Text);let s=new n(e,[t],[new n(e,[t.firstChild])]);return s=this.sub(new C(this.t,{},[]))(s),this.p._ref&&(this.p._ref.current=t),s}sub(e){return e==this?e=>e:e instanceof C&&this.t==e.t?t=>{let n=t.node[0],s=new Set(["_key","_ref","style","$style","checked","value"]);if(e.p._ref&&delete e.p._ref.current,this.p._ref&&(this.p._ref.current=n),!m([e.p.style,e.p.$style],[this.p.style,this.p.$style]))if("style"in e.p||"style"in this.p)n.removeAttribute("style"),"style"in this.p&&n.setAttribute("style",this.p.style),"$style"in this.p&&Object.assign(n.style,this.p.$style);else for(let t of new Set(Object.keys(this.p.$style||{})).union(new Set(Object.keys(e.p.$style||{}))))this.p.$style&&t in this.p.$style?e.p.$style?.[t]!=this.p.$style[t]&&(t.includes("-")?n.style.setProperty(t,this.p.$style[t]):n.style[t]=this.p.$style[t]):n.style.removeProperty(t);Object.is(e.p.checked,this.p.checked)||(n.checked=this.p.checked),Object.is(e.p.value,this.p.value)||(n.value="value"in this.p?this.p.value:"");let i=new Set(Object.keys(this.p)).union(new Set(Object.keys(e.p))).difference(s);for(let t of[...i].map((e=>e.match(/^\$?on(.*)/))).filter((e=>e)).map((e=>e[1])))m([e.p["on"+t],e.p["$on"+t]],[this.p["on"+t],this.p["$on"+t]])||(n.removeAttribute("on"+t),n["on"+t]=null,"on"+t in this.p&&n.setAttribute("on"+t,this.p["on"+t]),"$on"+t in this.p&&(n["on"+t]=this.p["$on"+t])),i.delete("on"+t),i.delete("$on"+t);for(let e of i)e in this.p?n.setAttribute(e,this.p[e]):n.removeAttribute(e);return new p({},this.c).sub(new p({},e.c))(t.child[0]),t}:super.sub(e)}},N={},S=new Proxy({},{get:(e,t)=>N[t]=N[t]||f(class extends C{constructor(e={},n){super(t,e,n)}})}),j=f(p),A=(e,t)=>new h(e,t);export{j as $fragment,A as $tn,t as Concept,y as Root,_ as component,S as dom,k as useCallback,d as useCommit,b as useEffect,v as useRef,g as useState};