let e=new Text;class t{constructor(e){this.p=e}sub(t){return n=>{let s=n.node[0];t.undoEffect(n);let i=this.make(n.root),r=i.node,o=t.getNode(n),c=s.parentNode;c.insertBefore(e,s);let l=new DocumentFragment;l.append(...r),c.insertBefore(l,e),c.removeChild(e);for(let e of new Set(o).difference(new Set(r)))c.removeChild(e);return i}}undoEffect(){}}class n{constructor(e,t,n=[]){this.child=n,this.concept=null,this.effect=[],this.functionConcept=null,this.node=t,this.ref={},this.root=e}}let s,i,r,o,c=class extends t{getNode(e){return[e.node[0]]}sub(e){return e instanceof c?e=>{let t=this.make(e.root);return e.node[0].parentNode.replaceChild(t.node[0],e.node[0]),e.child=t.child,e.node=t.node,e}:super.sub(e)}},l=class extends c{constructor(e,t){super(e),this.t=t}make(e){return new n(e,[new Text(this.t)])}sub(e){return e instanceof l?this.t==e.t?e=>e:e=>(e.node[0].nodeValue=this.t,e):super.sub(e)}},h=(e,t)=>{for(let n of e)t.parentNode.insertBefore(n,t.nextSibling),t=n},u=class extends t{constructor(e={},t){super(e),this.c=t.map((e=>"string"==typeof e?new l({},e):Symbol.iterator in e?new u({},e):e))}getNode(e){return[e.node[0],...this.c.flatMap(((t,n)=>t.getNode(e.child[n])))]}make(e){let t=this.c.map(((t,n)=>t.make(e)));return new n(e,[new Text,...t.flatMap((e=>e.node))],t)}sub(e){return e instanceof u?t=>{let n=t.node[0],s=[],i={};for(let[n,r]of e.c.entries()){let e=r.getNode(t.child[n]);"_key"in r.p?i[r.p._key]={i:n,node:e}:s.push({i:n,node:e}),e.at(-1)}let r={};{let e=0;for(let[t,n]of this.c.entries())"_key"in n.p?n.p._key in i&&(r[t]=i[n.p._key],delete i[n.p._key]):(e in s&&(r[t]=s[e],delete s[e]),e++)}for(let r of function*(){for(let e in s)yield s[e];for(let e of Reflect.ownKeys(i))yield i[e]}()){e.c[r.i].undoEffect(t.child[r.i]);for(let e of r.node)n.parentNode.removeChild(e)}let o=[],c=n;for(let[n,s]of this.c.entries()){let i;r[n]?(c.nextSibling!=r[n].node[0]&&h(r[n].node,c),i=s.sub(e.c[r[n].i])(t.child[r[n].i])):(i=s.make(t.root),h(i.node,c)),o.push(i),c=i.node.at(-1)}return t.child=o,t.node=[n,...o.flatMap((e=>e.node))],t}:super.sub(e)}undoEffect(e){this.c.map(((t,n)=>t.undoEffect(e.child[n])))}},p=e=>(t,...n)=>new e(t,n),f=()=>s.s,d=(e,t)=>{let n=s;s=e;try{return t()}finally{s=n}},a=class{#e;#t;#n;#s=[];render(e=this.concept){d(this.#t,(()=>{this.#n=e.sub(this.concept)(this.#n),this.concept=e}))}constructor(e){this.#t={a:()=>{this.#e=this.#e||requestAnimationFrame((()=>{this.#e=0,this.render()}))},s:()=>this.render()},this.concept=new l({}),this.#n=this.concept.make(this),this.node.append(...this.#n.node),e&&this.render(e)}flush(){d(this.#t,(()=>{this.#s.map((e=>e()))})),this.#s=[]}node=new DocumentFragment;push(e){this.#s.push(e),this.#e=this.#e||requestAnimationFrame((()=>{this.#e=0,this.flush()}))}unmount(){this.node.append(...this.#n.node)}},y=(e,t)=>e.length==t.length&&e.every(((e,n)=>Object.is(e,t[n]))),m=(e,t)=>{i.push([e,t])},b=(e,t)=>{let n=i;i=e;try{return t()}finally{i=n}},w=(e,t)=>{let n=k([e,t]);return y(n.current[1],t)||(n.current=[e,t]),n.current[0]},k=e=>o in r.ref?r.ref[o++]:r.ref[o++]={current:e},v=e=>{let t=r,n=[e,e=>{t.root.push((()=>{n[0]=e,t.concept.sub(t.concept)(t)}))}];return s.a,k(n).current},$=(e,t)=>{let n=r,s=o;r=e,o=0;try{return t()}finally{r=n,o=s}},g=class extends t{constructor(e,t,n){super(e),this.f=t,this.c=n}getNode(e){return e.functionConcept.getNode(e.child[0])}make(e){let t=new n(e);return t.functionConcept=b(t.effect,(()=>$(t,(()=>this.f(this.p,...this.c))))),t.child=[t.functionConcept.make(e)],t.concept=this,t.effect.map((e=>e[0]=e[0]())),t.node=t.child[0].node,t}sub(e){return e instanceof g&&this.f==e.f?e=>{let t=e.functionConcept,n=e.effect,s=[],i=b(s,(()=>$(e,(()=>this.f(this.p,...this.c))))),r=i.sub(t),o=n.map(((e,t)=>t)).filter((e=>{let t=n[e];return!(t[1]&&y(t[1],s[e][1]))}));return o.map((e=>n[e][0]?.())),e.child[0]=r(e.child[0]),e.functionConcept=i,o.map((e=>{let t=s[e];t[0]=t[0]()})),e.concept=this,e.effect=s,e.node=e.child[0].node,e}:super.sub(e)}undoEffect(e){e.effect.map((e=>e[0]?.())),e.effect=[],e.functionConcept.undoEffect(e.child[0])}},x=e=>(t,...n)=>new g(t,e,n),_=class extends c{constructor(e,t,n){super(t),this.t=e,this.c=n}make(e){let t=document.createElement(this.t);t.appendChild(new Text);let s=new n(e,[t],[new n(e,[t.firstChild])]);return s=this.sub(new _(this.t,{},[]))(s),this.p._ref&&(this.p._ref.current=t),s}sub(e){return e==this?e=>e:e instanceof _&&this.t==e.t?t=>{let n=t.node[0],s=new Set(["_key","_ref","style","$style","checked","value"]);if(e.p._ref&&delete e.p._ref.current,this.p._ref&&(this.p._ref.current=n),!y([e.p.style,e.p.$style],[this.p.style,this.p.$style]))if("style"in e.p||"style"in this.p)n.removeAttribute("style"),"style"in this.p&&n.setAttribute("style",this.p.style),"$style"in this.p&&Object.assign(n.style,this.p.$style);else for(let t of new Set(Object.keys(this.p.$style||{})).union(new Set(Object.keys(e.p.$style||{}))))this.p.$style&&t in this.p.$style?e.p.$style?.[t]!=this.p.$style[t]&&(t.includes("-")?n.style.setProperty(t,this.p.$style[t]):n.style[t]=this.p.$style[t]):n.style.removeProperty(t);Object.is(e.p.checked,this.p.checked)||(n.checked=this.p.checked),Object.is(e.p.value,this.p.value)||(n.value="value"in this.p?this.p.value:"");let i=new Set(Object.keys(this.p)).union(new Set(Object.keys(e.p))).difference(s);for(let t of[...i].map((e=>e.match(/^\$?on(.*)/))).filter((e=>e)).map((e=>e[1])))y([e.p["on"+t],e.p["$on"+t]],[this.p["on"+t],this.p["$on"+t]])||(n.removeAttribute("on"+t),n["on"+t]=null,"on"+t in this.p&&n.setAttribute("on"+t,this.p["on"+t]),"$on"+t in this.p&&(n["on"+t]=this.p["$on"+t])),i.delete("on"+t),i.delete("$on"+t);for(let e of i)e in this.p?n.setAttribute(e,this.p[e]):n.removeAttribute(e);return new u({},this.c).sub(new u({},e.c))(t.child[0]),t}:super.sub(e)}},C={},N=new Proxy({},{get:(e,t)=>C[t]=C[t]||p(class extends _{constructor(e={},n){super(t,e,n)}})}),S=p(u),j=(e,t)=>new l(e,t);export{S as $fragment,j as $tn,t as Concept,a as Root,x as component,N as dom,w as useCallback,f as useCommit,m as useEffect,k as useRef,v as useState};