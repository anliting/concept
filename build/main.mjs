let e=new Text;class t{constructor(e){this.p=e}sub(t){return n=>{let s=n.node[0];t.undoEffect(n);let i=this.make(n.root),r=i.node,o=n.node,h=s.parentNode;h.insertBefore(e,s);let l=new DocumentFragment;l.append(...r),h.insertBefore(l,e),h.removeChild(e);for(let e of new Set(o).difference(new Set(r)))h.removeChild(e);return i}}undoEffect(){}}class n{constructor(e,t,n=[]){this.child=n,this.clean=1,this.concept=null,this.effect=[],this.functionConcept=null,this.node=t,this.ref={},this.root=e}}let s=class extends t{sub(e){return e instanceof s?e=>{let t=this.make(e.root);return e.node[0].parentNode.replaceChild(t.node[0],e.node[0]),e.child=t.child,e.node=t.node,e}:super.sub(e)}},i=class extends s{constructor(e,t){super(e),this.t=t}make(e){return new n(e,[new Text(this.t)])}sub(e){return e instanceof i?this.t==e.t?e=>e:e=>(e.node[0].nodeValue=this.t,e):super.sub(e)}},r=(e,t)=>{for(let n of e)t.parentNode.insertBefore(n,t.nextSibling),t=n},o=class extends t{constructor(e={},t){super(e),this.c=t.map(e=>"string"==typeof e?new i({},e):Symbol.iterator in e?new o({},e):e)}make(e){let t=this.c.map((t,n)=>t.make(e));return new n(e,[new Text,...t.flatMap(e=>e.node)],t)}sub(e){return e instanceof o?t=>{let n=t.node[0],s=[],i={};for(let[n,r]of e.c.entries()){let e=t.child[n].node;"key"in r.p?i[r.p.key]={i:n,node:e}:s.push({i:n,node:e}),e.at(-1)}let o={};{let e=0;for(let[t,n]of this.c.entries())"key"in n.p?n.p.key in i&&(o[t]=i[n.p.key],delete i[n.p.key]):(e in s&&(o[t]=s[e],delete s[e]),e++)}for(let r of function*(){for(let e in s)yield s[e];for(let e of Reflect.ownKeys(i))yield i[e]}()){e.c[r.i].undoEffect(t.child[r.i]);for(let e of r.node)n.parentNode.removeChild(e)}let h=[],l=n;for(let[n,s]of this.c.entries()){let i;o[n]?(l.nextSibling!=o[n].node[0]&&r(o[n].node,l),i=s.sub(e.c[o[n].i])(t.child[o[n].i])):(i=s.make(t.root),r(i.node,l)),h.push(i),l=i.node.at(-1)}return t.child=h,t.node=[n,...h.flatMap(e=>e.node)],t}:super.sub(e)}undoEffect(e){this.c.map((t,n)=>t.undoEffect(e.child[n]))}},h=e=>(t,...n)=>new e(t,n);class l{#e=[];#t=0;pop(){let e=this.#e[this.#t];return this.#e[this.#t++]=void 0,this.#t>64&&2*this.#t>this.#e.length&&(this.#e=this.#e.slice(this.#t),this.#t=0),e}push(e){this.#e.push(e)}get size(){return this.#e.length-this.#t}[Symbol.iterator](){return{next:()=>this.size?{value:this.pop(),done:!1}:{done:!0}}}}let c,p,u,f=class{#n;#s;#i=new l;render(e=this.concept){this.#s=e.sub(this.concept)(this.#s),this.concept=e}constructor(e){this.concept=new i({}),this.#s=this.concept.make(this),this.node.append(...this.#s.node),e&&this.render(e)}flush(){for(let e of this.#i)e()}node=new DocumentFragment;push(e){this.#i.push(e),this.#n=this.#n||requestAnimationFrame(()=>{this.#n=0,this.flush()})}unmount(){this.node.append(...this.#s.node)}},d=(e,t)=>e.length==t.length&&e.every((e,n)=>Object.is(e,t[n])),a=(e,t)=>{c.push([e,t])},y=(e,t)=>{let n=c;c=e;try{return t()}finally{c=n}},m=(e,t)=>{let n=w([e,t]);return d(n.current[1],t)||(n.current=[e,t]),n.current[0]},b=(e,t)=>{let n=w(null);return n.current&&d(n.current[1],t)||(n.current=[e(),t]),n.current[0]},w=e=>u in p.ref?p.ref[u++]:p.ref[u++]={current:e},k=e=>{let t=p,n=[e,e=>{t.root.push(()=>{n[0]=e,t.clean=0,t.concept.sub(t.concept)(t)})}];return w(n).current},v=(e,t)=>{let n=p,s=u;p=e,u=0;try{return t()}finally{p=n,u=s}},S=class extends t{constructor(e,t,n){super(e),this.f=t,this.c=n}make(e){let t=new n(e);return t.functionConcept=y(t.effect,()=>v(t,()=>this.f(this.p,...this.c))),t.child=[t.functionConcept.make(e)],t.concept=this,t.effect.map(e=>e[0]=e[0]()),t.node=t.child[0].node,t}sub(e){return e instanceof S&&this.f==e.f?t=>{if(((e,t)=>{let n=Reflect.ownKeys(e),s=Reflect.ownKeys(t);return n.length==s.length&&n.every(n=>n in t&&Object.is(e[n],t[n]))})(e.p,this.p)&&d(e.c,this.c)&&t.clean)return t;let n=t.functionConcept,s=t.effect,i=[],r=y(i,()=>v(t,()=>this.f(this.p,...this.c))),o=r.sub(n),h=s.map((e,t)=>t).filter(e=>{let t=s[e];return!(t[1]&&d(t[1],i[e][1]))});return h.map(e=>s[e][0]?.()),t.child[0]=o(t.child[0]),t.functionConcept=r,h.map(e=>{let t=i[e];t[0]=t[0]()}),t.clean=1,t.concept=this,t.effect=i,t.node=t.child[0].node,t}:super.sub(e)}undoEffect(e){e.effect.map(e=>e[0]?.()),e.effect=[],e.functionConcept.undoEffect(e.child[0])}},O=e=>(t,...n)=>new S(t,e,n),x=class extends s{constructor(e,t,n){super(t),this.t=e,this.c=n}make(e){let t=document.createElement(this.t);t.appendChild(new Text);let s=new n(e,[t],[new n(e,[t.firstChild])]);return s=this.sub(new x(this.t,{},[]))(s),this.p.ref&&(this.p.ref.current=t),s}sub(e){return e==this?e=>e:e instanceof x&&this.t==e.t?t=>{new o({},this.c).sub(new o({},e.c))(t.child[0]);let n=t.node[0],s=new Set(["key","ref","checked","innerHTML","style","Style","value"]);if(e.p.ref&&delete e.p.ref.current,this.p.ref&&(this.p.ref.current=n),Object.is(e.p.checked,this.p.checked)||(n.checked=this.p.checked),Object.is(e.p.innerHTML,this.p.innerHTML)||(n.innerHTML=this.p.innerHTML),!d([e.p.style,e.p.Style],[this.p.style,this.p.Style]))if("Style"in e.p||"Style"in this.p){n.removeAttribute("style"),"Style"in this.p&&n.setAttribute("style",this.p.Style),"style"in this.p&&Object.assign(n.style,this.p.style);for(let e of Object.keys(this.p.style||{}))e.includes("-")?n.style.setProperty(e,this.p.style[e]):n.style[e]=this.p.style[e]}else for(let t of new Set(Object.keys(this.p.style||{})).union(new Set(Object.keys(e.p.style||{}))))this.p.style&&t in this.p.style?e.p.style?.[t]!=this.p.style[t]&&(t.includes("-")?n.style.setProperty(t,this.p.style[t]):n.style[t]=this.p.style[t]):n.style.removeProperty(t);Object.is(e.p.value,this.p.value)||(n.value="value"in this.p?this.p.value:"");let i=new Set(Object.keys(this.p)).union(new Set(Object.keys(e.p))).difference(s);for(let t of[...i].map(e=>e.match(/^[Oo]n(.*)/)).filter(e=>e).map(e=>e[1]))d([e.p["on"+t],e.p["On"+t]],[this.p["on"+t],this.p["On"+t]])||(n.removeAttribute("on"+t),n["on"+t]=null,"on"+t in this.p&&(n["on"+t]=this.p["on"+t]),"On"+t in this.p&&n.setAttribute("on"+t,this.p["On"+t])),i.delete("on"+t),i.delete("On"+t);for(let e of i)e in this.p?n.setAttribute(e,this.p[e]):n.removeAttribute(e);return t}:super.sub(e)}},g={},C=new Proxy({},{get:(e,t)=>g[t]=g[t]||h(class extends x{constructor(e={},n){super(t,e,n)}})}),j=h(o),T=(e,t)=>new i(e,t);export{j as $fragment,T as $tn,t as Concept,f as Root,O as component,C as dom,m as useCallback,a as useEffect,b as useMemo,w as useRef,k as useState};