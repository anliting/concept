let e=new Text;class t{constructor(e){this.p=e}sub(t){return n=>{let s=n.node[0];t.undoEffect(n);let r=this.make(n.root),i=r.node,o=n.node,h=s.parentNode;h.insertBefore(e,s);let l=new DocumentFragment;l.append(...i),h.insertBefore(l,e),h.removeChild(e);for(let e of new Set(o).difference(new Set(i)))h.removeChild(e);return r}}undoEffect(){}}class n{constructor(e,t,n=[]){this.child=n,this.clean=1,this.concept=null,this.effect=[],this.functionConcept=null,this.node=t,this.ref={},this.root=e}}let s=class extends t{sub(e){return e instanceof s?e=>{let t=this.make(e.root);return e.node[0].parentNode.replaceChild(t.node[0],e.node[0]),e.child=t.child,e.node=t.node,e}:super.sub(e)}},r=class extends s{constructor(e,t){super(e),this.t=t}make(e){return new n(e,[new Text(this.t)])}sub(e){return e instanceof r?this.t==e.t?e=>e:e=>(e.node[0].nodeValue=this.t,e):super.sub(e)}},i=(e,t)=>{for(let n of e)t.parentNode.insertBefore(n,t.nextSibling),t=n},o=class extends t{constructor(e={},t){super(e),this.c=t.map(e=>"string"==typeof e?new r({},e):Symbol.iterator in e?new o({},e):e)}make(e){let t=this.c.map((t,n)=>t.make(e));return new n(e,[new Text,...t.flatMap(e=>e.node)],t)}sub(e){return e instanceof o?t=>{let n=t.node[0],s=[],r={};for(let[n,i]of e.c.entries()){let e=t.child[n].node;"_key"in i.p?r[i.p._key]={i:n,node:e}:s.push({i:n,node:e}),e.at(-1)}let o={};{let e=0;for(let[t,n]of this.c.entries())"_key"in n.p?n.p._key in r&&(o[t]=r[n.p._key],delete r[n.p._key]):(e in s&&(o[t]=s[e],delete s[e]),e++)}for(let i of function*(){for(let e in s)yield s[e];for(let e of Reflect.ownKeys(r))yield r[e]}()){e.c[i.i].undoEffect(t.child[i.i]);for(let e of i.node)n.parentNode.removeChild(e)}let h=[],l=n;for(let[n,s]of this.c.entries()){let r;o[n]?(l.nextSibling!=o[n].node[0]&&i(o[n].node,l),r=s.sub(e.c[o[n].i])(t.child[o[n].i])):(r=s.make(t.root),i(r.node,l)),h.push(r),l=r.node.at(-1)}return t.child=h,t.node=[n,...h.flatMap(e=>e.node)],t}:super.sub(e)}undoEffect(e){this.c.map((t,n)=>t.undoEffect(e.child[n]))}},h=e=>(t,...n)=>new e(t,n);class l{#e=[];#t=0;pop(){let e=this.#e[this.#t];return this.#e[this.#t++]=void 0,this.#t>64&&2*this.#t>this.#e.length&&(this.#e=this.#e.slice(this.#t),this.#t=0),e}push(e){this.#e.push(e)}get size(){return this.#e.length-this.#t}[Symbol.iterator](){return{next:()=>this.size?{value:this.pop(),done:!1}:{done:!0}}}}let c,p,u,f=class{#n;#s;#r=new l;render(e=this.concept){this.#s=e.sub(this.concept)(this.#s),this.concept=e}constructor(e){this.concept=new r({}),this.#s=this.concept.make(this),this.node.append(...this.#s.node),e&&this.render(e)}flush(){for(let e of this.#r)e()}node=new DocumentFragment;push(e){this.#r.push(e),this.#n=this.#n||requestAnimationFrame(()=>{this.#n=0,this.flush()})}unmount(){this.node.append(...this.#s.node)}},d=(e,t)=>e.length==t.length&&e.every((e,n)=>Object.is(e,t[n])),a=(e,t)=>{c.push([e,t])},y=(e,t)=>{let n=c;c=e;try{return t()}finally{c=n}},m=(e,t)=>{let n=w([e,t]);return d(n.current[1],t)||(n.current=[e,t]),n.current[0]},b=(e,t)=>{let n=w(null);return n.current&&d(n.current[1],t)||(n.current=[e(),t]),n.current[0]},w=e=>u in p.ref?p.ref[u++]:p.ref[u++]={current:e},k=e=>{let t=p,n=[e,e=>{t.root.push(()=>{n[0]=e,t.clean=0,t.concept.sub(t.concept)(t)})}];return w(n).current},v=(e,t)=>{let n=p,s=u;p=e,u=0;try{return t()}finally{p=n,u=s}},$=class extends t{constructor(e,t,n){super(e),this.f=t,this.c=n}make(e){let t=new n(e);return t.functionConcept=y(t.effect,()=>v(t,()=>this.f(this.p,...this.c))),t.child=[t.functionConcept.make(e)],t.concept=this,t.effect.map(e=>e[0]=e[0]()),t.node=t.child[0].node,t}sub(e){return e instanceof $&&this.f==e.f?t=>{if(((e,t)=>{let n=Reflect.ownKeys(e),s=Reflect.ownKeys(t);return n.length==s.length&&n.every(n=>n in t&&Object.is(e[n],t[n]))})(e.p,this.p)&&d(e.c,this.c)&&t.clean)return t;let n=t.functionConcept,s=t.effect,r=[],i=y(r,()=>v(t,()=>this.f(this.p,...this.c))),o=i.sub(n),h=s.map((e,t)=>t).filter(e=>{let t=s[e];return!(t[1]&&d(t[1],r[e][1]))});return h.map(e=>s[e][0]?.()),t.child[0]=o(t.child[0]),t.functionConcept=i,h.map(e=>{let t=r[e];t[0]=t[0]()}),t.clean=1,t.concept=this,t.effect=r,t.node=t.child[0].node,t}:super.sub(e)}undoEffect(e){e.effect.map(e=>e[0]?.()),e.effect=[],e.functionConcept.undoEffect(e.child[0])}},x=e=>(t,...n)=>new $(t,e,n),g=class extends s{constructor(e,t,n){super(t),this.t=e,this.c=n}make(e){let t=document.createElement(this.t);t.appendChild(new Text);let s=new n(e,[t],[new n(e,[t.firstChild])]);return s=this.sub(new g(this.t,{},[]))(s),this.p._ref&&(this.p._ref.current=t),s}sub(e){return e==this?e=>e:e instanceof g&&this.t==e.t?t=>{new o({},this.c).sub(new o({},e.c))(t.child[0]);let n=t.node[0],s=new Set(["_key","_ref","style","$style","checked","value"]);if(e.p._ref&&delete e.p._ref.current,this.p._ref&&(this.p._ref.current=n),!d([e.p.style,e.p.$style],[this.p.style,this.p.$style]))if("style"in e.p||"style"in this.p){n.removeAttribute("style"),"style"in this.p&&n.setAttribute("style",this.p.style),"$style"in this.p&&Object.assign(n.style,this.p.$style);for(let e of Object.keys(this.p.$style||{}))e.includes("-")?n.style.setProperty(e,this.p.$style[e]):n.style[e]=this.p.$style[e]}else for(let t of new Set(Object.keys(this.p.$style||{})).union(new Set(Object.keys(e.p.$style||{}))))this.p.$style&&t in this.p.$style?e.p.$style?.[t]!=this.p.$style[t]&&(t.includes("-")?n.style.setProperty(t,this.p.$style[t]):n.style[t]=this.p.$style[t]):n.style.removeProperty(t);Object.is(e.p.checked,this.p.checked)||(n.checked=this.p.checked),Object.is(e.p.value,this.p.value)||(n.value="value"in this.p?this.p.value:"");let r=new Set(Object.keys(this.p)).union(new Set(Object.keys(e.p))).difference(s);for(let t of[...r].map(e=>e.match(/^\$?on(.*)/)).filter(e=>e).map(e=>e[1]))d([e.p["on"+t],e.p["$on"+t]],[this.p["on"+t],this.p["$on"+t]])||(n.removeAttribute("on"+t),n["on"+t]=null,"on"+t in this.p&&n.setAttribute("on"+t,this.p["on"+t]),"$on"+t in this.p&&(n["on"+t]=this.p["$on"+t])),r.delete("on"+t),r.delete("$on"+t);for(let e of r)e in this.p?n.setAttribute(e,this.p[e]):n.removeAttribute(e);return t}:super.sub(e)}},_={},C=new Proxy({},{get:(e,t)=>_[t]=_[t]||h(class extends g{constructor(e={},n){super(t,e,n)}})}),S=h(o),j=(e,t)=>new r(e,t);export{S as $fragment,j as $tn,t as Concept,f as Root,x as component,C as dom,m as useCallback,a as useEffect,b as useMemo,w as useRef,k as useState};